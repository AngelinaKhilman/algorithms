(Время: 1 сек. Память: 16 Мб Сложность: 27%)
Рассмотрим бесконечный лист клетчатой бумаги. Закрасим некоторое множество клеток в черный цвет. Теперь мы хотим закрасить минимальное количество клеток, так, чтобы множество черных клеток стало выпуклым.

Напомним, что геометрическая фигура Φ называется выпуклой, если для любых точек A из Φ и В из Φ с вещественными координатами отрезок [AB] принадлежит Φ.

Входные данные
В первой строке входного файла INPUT.TXT содержатся два числа N и M (1 ≤ N, M ≤ 100) — размеры куска бумаги, куда попали все черные клетки. В каждой из следующих N строк содержится М символов «*» или «.». Символ «*» обозначает черную клетку, а «.» белую.

Выходные данные
В выходной файл OUTPUT.TXT выведите выпуклое множество, содержащее минимальное количество дополнительно покрашенных черных клеток, в ровно N строках по M символов «*» или «.» в каждой.






#include<bits/stdc++.h>

using namespace std;

const int INF = 1000000000;

int main() {
    int n, m;
    string k;
    cin >> n;
    cin >> m;
    vector < vector <char > > v(n);
    for (int i = 0; i < n; i++){
            cin >> k;
        for (int j = 0; j < m; j++){
            v[i].push_back(k[j]);
        }
    }

    int minj = m;
    int maxj = 0;
    int maxi = 0;
    int mini = n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++){
            if (v[i][j] == '*' && j < minj)
                minj = j;
            if (v[i][j] == '*' && j > maxj)
                maxj = j;
            if (v[i][j] == '*' && i < mini)
                mini = i;
            if (v[i][j] == '*' && i > maxi)
                maxi = i;
    }
    for (int i = mini; i <= maxi; i++){
        for (int j = minj; j <= maxj; j++){
            v[i][j] = '*';
        }
    }
    for (size_t i = 0; i < n; i++){
        for (size_t j = 0; j < m; j++){
            cout << v[i][j];
        }
        cout << endl;
    }



    return 0;
}
