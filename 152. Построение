(Время: 1 сек. Память: 16 Мб Сложность: 46%)
Группа солдат-новобранцев прибыла в армейскую часть N666. После знакомства с прапорщиком стало очевидно, что от работ на кухне по очистке картофеля спасти солдат может только чудо.

Прапорщик, будучи не в состоянии запомнить фамилии, пронумеровал новобранцев от 1 до N. После этого он велел им построиться по росту (начиная с самого высокого). С этой несложной задачей могут справиться даже совсем необученные новобранцы, да вот беда, прапорщик уверил себя, что знает про некоторых солдат, кто из них кого выше, и это далеко не всегда соответствует истине.

После трех дней обучения новобранцам удалось выяснить, что знает (а точнее, думает, что знает) прапорщик. Помогите им, используя эти знания, построиться так, чтобы товарищ прапорщик остался доволен.

Входные данные
Во входном файле INPUT.TXT сначала идут числа N и M (1 ≤ N ≤ 100, 1 ≤ M ≤ 5000) - количество солдат в роте и количество пар солдат, про которых прапорщик знает, кто из них выше. Далее идут эти пары чисел A и B по одной на строке (1 ≤ A,B ≤ N), что означает, что, по мнению прапорщика, солдат A выше, чем B.

Выходные данные
В выходной файл OUTPUT.TXT выведите "Yes" если можно построиться так, чтобы прапорщик остался доволен и "No" если нельзя.




#include <bits/stdc++.h>
 
using namespace std;
 
int clStart, clEnd;
int n, m;
vector <vector <int> > g(100);
vector <int>  cl(100, 0);
bool dfs(int v){
    cl[v] = 1;
    for (int i = 0; i < g[v].size(); i++){
        int to = g[v][i];
        if (cl[to] == 0)
        {
            if (dfs(to))
            {
                return true;
            }
 
        }
        else if(cl[to] == 1){
           clEnd = v;
            clStart = to;
           return true;
        }
 
    }
    cl[v] = 2;
    return false;
}
 
int main() {
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    ios_base::sync_with_stdio(false);
    cin >> n;
    cin >> m;
    int a, b;
    for (int i = 0; i < m; i++){
        cin >> a;
        cin >> b;
        g[a - 1].push_back(b - 1);
    }
    clStart = -1;
    for (int i=0; i<n; ++i)
        if (dfs (i))
            break;
 
    if (clStart == -1)
        cout << "Yes" << endl;
    else
        cout << "No" << endl;
 
    return 0;
}
