(Время: 1 сек. Память: 16 Мб Сложность: 29%)
В стране Амбер очень сложные торгово-финансовые отношения. Если один торговец хочет обменять свой товар на товар другого торговца, тогда они идут в Торговую Гильдию Амбера. Наверное, вы подумали, что торговцы просто обменяются товарами и уйдут в разные стороны довольными от выгодной сделки? Как бы ни так! Законы в Амбере таковы, что Торговая Гильдия может получить прибыль от сделки между двумя торговцами, равную нормирующему коэффициенту одного из торговцев, только в том случае, когда нормирующие коэффициенты этих торговцев совпадут. Вы, наверное, не знаете что такое нормирующий коэффициент в Амбере? Это не удивительно…

Пусть торговцу N лет. В стране, откуда он приехал, для расчета операций с денежными единицами, действует система счисления с основанием P. Его нормирующим коэффициентом называется сумма цифр числа N в системе счисления с основанием P.

Напишите программу, которая покажет, сколько сможет заработать Торговая Гильдия после заключения сделки между двумя торговцами.

Входные данные
В первой строке входного файла INPUT.TXT содержится данные о первом торговце - числа N1 и P1, а во второй – данные о втором торговце – N2 и P2. Где N1 и N2 – возраст двух торговцев, которые хотят заключить сделку (0 ≤ N1, N2 ≤ 2147483647), а P1 и P2 – основания систем счисления, действующие в их странах (2 ≤ P1, P2 ≤ 16).

Выходные данные
В выходной файл OUTPUT.TXT вывести, сколько заработает Торговая Гильдия после заключения сделки между торговцами.

def cb(num, to_base = 10, from_base = 10):
    if isinstance(num, str):
        n = int(num, from_base)
    else:
        n = int(num)
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if n < to_base:
        return alphabet[n]
    else:
        return cb(n // to_base, to_base) + alphabet[n % to_base]
 
def zif(n):
    k = str(n)
    arr = list(k)
    if len(arr) == len(set(arr)):
        return False
    return True
import math
import random
def v2(r, z, A, B, sigma, ro, a):
    res = A * ((B / r) ** ro - math.exp(-0.0070975 * z * z)) * math.exp(sigma / (r - a))
    return res
 
def main():
    input_file = open("input.txt", "r")
    output_file = open("output.txt", "w")
    line = input_file.readline().split()
    n1, k1 = int(line[0]), int(line[1])
    line = input_file.readline().split()
    n2, k2 = int(line[0]), int(line[1])
    arr = [('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', 5), ('F', 6), ("G", 7), ("H", 8), ("I", 9), ("J", 10), ("K", 11), ("L", 12), ("M", 13), ("N", 14), ("O", 15), ("P", 16), ("Q", 17), ("R", 18), ("S", 19), ("T", 20), ("U", 21), ("V", 22), ("W", 23), ("X", 24), ("Y", 25), ("Z", 26)]
    l1 = list(cb(n1, k1, 10))
    print(l1)
    for i in range(len(l1)):
        for j in range(len(arr)):
            if l1[i] == arr[j][0]:
                l1[i] = 9 + int(arr[j][1])
 
    l2 = list(cb(n2, k2, 10))
    for i in range(len(l2)):
        for j in range(len(arr)):
            if l2[i] == arr[j][0]:
                l2[i] = 9 + int(arr[j][1])
    print(l2)
    sum1, sum2 = 0, 0
    for i in range(len(l1)):
        sum1 += int(l1[i])
    for i in range(len(l2)):
        sum2 += int(l2[i])
    print(sum1, sum2)
    if sum1 == sum2:
        ans = sum1
    else:
        ans = 0
    output_file.write(str(ans) + "\n")
 
 
    input_file.close()
    output_file.close()
 
 
if __name__ == "__main__":
    main()
