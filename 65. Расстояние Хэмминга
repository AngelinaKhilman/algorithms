(Время: 1 сек. Память: 16 Мб Сложность: 27%)
В связи с особенностями линии связи, используемой для передачи сообщений из пункта A в пункт B, каждый бит принятого сообщения с вероятностью 0.001 содержит ошибку.

Из пункта A в пункт B было послано одно из n сообщений m1, m2, ..., mn. В пункте B было принято сообщение s.

Ваша задача заключается в определении наиболее вероятного исходного сообщения. Очевидно, что оно будет одним из тех сообщений, расстояние Хэмминга между которым и строкой s минимально.

Расстоянием Хэмминга двух строк a и b одинаковой длины называется количество позиций, в которых эти строки различаются (количество элементов в множестве {i | 1 ≤ i ≤ |a|, ai ≠ bi }).

Входные данные
Первая строка входного файла INPUT.TXT содержит s — принятое сообщение. Вторая строка содержит целое число n — количество сообщений, которые могли быть отправлены. Следующие n строк содержат mi — эти сообщения. Длины всех сообщений равны (|s| = |m1| = |m2| = ... = |mn|). Сообщения непустые, состоят только из символов 0 и 1. Размер входного файла не превосходит 60 Кб.

Выходные данные
В первую строку выходного файла OUTPUT.TXT выведите k — количество сообщений, на которых достигается минимум расстояния Хэмминга. Во вторую строку выведите в порядке возрастания k чисел — номера этих сообщений.


def main():
    input_file = open("input.txt", "r")
    output_file = open("output.txt", "w")
    line = input_file.readline().split()
    s = list(line[0])
    print(s)
    line = input_file.readline().split()
    m = int(line[0])
    if m == 0:
        output_file.write('0\n')
        output_file.close()
        exit(0)
    a = []
    for i in range(m):
        line = input_file.readline().strip()
        line = list(line)
        a.append(list(line))
    c = [0] * m
    q = [0] * m
    for i in range(m):
        count = 0
        for j in range(len(s)):
            if int(a[i][j]) ^ int(s[j]) != 0:
                count += 1
        c[i] = count
        q[i] = i + 1
    print(c, q)
  
    minn = min(c)
    print(minn)
    count = c.count(minn)
    print(count)
    res = []
    for i in range(m):
        if c[i] == minn:
            res.append(q[i])
    output_file.write(str(count) + '\n')
    if len(res):
        output_file.write(str(' '.join([str(x) for x in res])) + '\n')
    else:
        output_file.write('\n')
  
  
if __name__ == "__main__":
    main()
