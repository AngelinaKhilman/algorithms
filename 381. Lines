(Время: 1 сек. Память: 16 Мб Сложность: 43%)
В таблице из N строк и N столбцов некоторые клетки заняты шариками, другие свободны. Выбран шарик, который нужно переместить, и место, куда его нужно переместить. Выбранный шарик за один шаг перемещается в соседнюю по горизонтали или вертикали свободную клетку. Требуется выяснить, возможно ли переместить шарик из начальной клетки в заданную, и, если возможно, то найти путь из наименьшего количества шагов.

Входные данные
В первой строке входного файла INPUT.TXT находится число N, в следующих N строках - по N символов. Символом точки обозначена свободная клетка, английской заглавной O - шарик, @ - исходное положение шарика, который должен двигаться, английской заглавной X - конечное положение шарика. (2 ≤ N ≤ 40)

Выходные данные
В выходной файл OUTPUT.TXT выведите в первой строке Yes, если движение возможно, или No, если нет. Если движение возможно, то далее следует вывести N строк по N символов - как и на вводе, но букву X, а также все точки по пути следует заменить плюсами. Если решений несколько, выведите любое.

#include<bits/stdc++.h>
 
using namespace std;
 
int main() {
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    ios_base::sync_with_stdio(false);
    int n, vh, vyh, vyhi, vyhj;
    cin >> n;
    char a[n][n];
 
    for (int i = 0; i < n; i++){
         string s;
         cin >> s;
        for (int j = 0; j < n; j++){
 
            a[i][j] = s[j];
 
            if (a[i][j] == '@'){
                vh = i * n + j;
            }
             if (a[i][j] == 'X'){
                vyh = i * n + j;
               vyhi = i;
                vyhj = j;
            }
        }
    }
 
    vector<vector <int> > v;
    v.resize(n * n);
 
 
    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            if (i + 1 < n)
                if (a[i + 1][j] != 'O')
                    v[i * n + j].push_back((i + 1) * n + j);
            if (j + 1 < n)
                if (a[i][j + 1] != 'O')
                    v[i * n + j].push_back(i * n + (j + 1));
            if (i - 1 >= 0)
                if (a[i - 1][j] != 'O')
                    v[i * n + j].push_back((i - 1) * n + j);
            if (j - 1 >= 0)
                if (a[i][j - 1] != 'O')
                    v[i * n + j].push_back(i * n + (j - 1));
        }
    }
 
 
 
    int d[n * n];
    for (int j = 0; j < n * n; j++){
        d[j] = 999999999;
    }
    d[vh] = 0;
    int p[n * n];
    for (int i = 0; i < n * n; i++){
        p[i] = -1;
    }
    int visited[n * n];
    for (int j = 0; j < n * n; j ++){
        visited[j] = 0;
    }
    for (int t = 0; t < n * n; t++){
        int INF = 999999999;
        int k = 0;
        for (int l = 0; l < n * n; l++){
            if (d[l] < INF && visited[l] < 1){
                INF = d[l];
                k = l;
            }
        }
        if (d[k] == 999999999){
            break;
        }
        visited[k] = 1;
        for (int r = 0; r < n * n; r++){
                int qwe = 999999999;
        for (size_t it = 0; it < v[k].size(); it++)
        {
            if (v[k][it] == r){
                qwe = 1;
            }
        }
            if(qwe + d[k] < d[r]){
                d[r] = qwe + d[k];
                p[r] = k;
            }
        }
    }
 
 
    if (d[vyh] == 999999999){
        string ans = "No";
        cout << ans << "\n";
    }
    else{
        string ans = "Yes";
        vector <int> path;
        int cur = vyh;
        while (cur != -1){
            cur = p[cur];
 
            path.push_back(cur);
        }
 
        for (size_t i = 0; i < (path.size() - 2); i++){
            int qwerty = path[i] / n;
            int yuio = path[i] - (qwerty * n);
            a[qwerty][yuio] = '+';
        }
        a[vyhi][vyhj] = '+';
        cout << ans << "\n";
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                cout << a[i][j];
            }
            cout << "\n";
        }
    }
 
    return 0;
}
